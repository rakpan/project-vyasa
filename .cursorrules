# Project Vyasa: The Local Agentic Research Factory

You are an expert AI Research Engineer building "Project Vyasa," a high-performance, thesis-driven research engine running locally on NVIDIA DGX.

## 1. Core Philosophy (The "Native Vision")
- **Factory, Not Chatbot:** We build artifacts (Graphs, Manuscripts), not conversations.
- **Intent-Driven:** All execution is downstream of a `ProjectConfig` (Thesis + RQs + Anti-Scope).
- **System of Record:** The Graph (ArangoDB) is the source of truth. External LLMs are untrusted "Outside Reviewers" (see Section 5).
- **Block-Based:** Manuscripts are lists of bound blocks (Text + ClaimIDs + CitationKeys), not raw strings.

## 2. The Fusion Stack (Architecture)
Use strictly functional names in code and APIs (project, claim, block, patch, guard). Avoid metaphor names for core components.

- **Orchestrator** (`orchestrator` @ :8000): Python + LangGraph. Owns state machines, workflow loops, retries, and tool calls.
- **The Scout** (`firecrawl` @ :3002): 
  - **Function:** Retrieval Sidecar (Firecrawl).
  - **Invariant:** Must be accessed via HTTP only (no SDK imports) to preserve AGPL boundaries. Dumb retrieval only; no reasoning.
- **Cortex** (`cortex-*` @ :30000+):
  - **The Cartographer** (Worker): High-recall triple/entity extraction.
  - **The Librarian** (Librarian): Chunking and semantic summary generation.
  - **The Lead Counsel** (New): Strategic triage (Summary vs. Detail) and format selection.
  - **The Logician** (New): Mathematical autoformalization (Python/SymPy/LaTeX).
  - **The Synthesizer** (New): Attorney-style, evidence-led prose generation.
  - **The Critic** (Critic): Logic, schema, and evidentiary validation.
- **Graph** (`graph` @ :8529): ArangoDB. Stores Projects, Documents, Claims, Manuscripts, Revisions, Reviews.
- **Console** (`console` @ :3000): Next.js. Project management + editorial workbench (section editor + redline review).
- **Vector** (`vector` @ :6333): Retrieval index behind an interface (Qdrant or pgvector). Used for semantic search over chunks/claims.

## 3. The Four Kernels (Domain Logic)
Organize code into these four domains (folders/modules/services). Do not blur responsibilities.

### A. Project Kernel (Intent)
- **Responsibility:** Scope & direction.
- **Key Object:** `ProjectConfig` (Thesis, RQs, Anti-Scope, Seed Corpus, Target Journal profile).
- **Invariant:** No agent runs without a `project_id`. Project context is injected into every prompt/tool call.

### B. Knowledge Kernel (Evidence)
- **Responsibility:** Ingestion & alignment.
- **Key Object:** `Claim` (claim_text, confidence, evidence_spans, source pointers).
- **Sources:** - **PDF:** Local upload -> Layout Extraction.
  - **Web:** Google Discovery -> Firecrawl Scrape (Markdown).
- **Logic:**
  - Extract broadly (high recall).
  - **Tag** priority (`HIGH`/`LOW`) based on Project RQs.
  - Do NOT hard-filter at ingestion; tag and rank instead.

### C. Manuscript Kernel (Production)
- **Responsibility:** Assembly, edits, versioning.
- **Key Objects:** `Block` (Paragraph/Figure/Table/Equation) and `Patch` (Edit Operation).
- **Invariant:** Every text block must bind to specific `Claim_IDs` and `Citation_Keys`.
- **Editing Model:** Agents propose patches (block-level replace/insert/delete). Humans accept/reject (redline review).

### D. Governance Kernel (Quality)
- **Responsibility:** Safety & validation gates.
- **Key Objects:** `Guard` (Drift, Citation, Evidence, Contract).
- **Logic:** Roles (prompts) are versioned configuration in the DB, not hardcoded strings in code.
- **Vocabulary Guardrails**: The Synthesizer must strictly avoid words defined in `forbidden_vocab.yaml`. The Critic is the final gate; it must fail any block containing prohibited terms.

### E. Strategic Synthesis (Logic Expansion)
- **Mathematical Representation**: If a section involves quantitative trends, trigger **The Logician** to generate symbolic proofs ($LaTeX$) and Python verification code.
- **Attorney-Style Rigor**: Prose must be evidence-led, removing redundancy by summarizing "explained-before" context while providing detailed interpretation for foundational proofs.
- **OOB Bridge (Sideloading)**: External research (Perplexity) is ingested as a `human_injected` Knowledge Fragment. It must be processed by the Cartographer before triggering a "Reprocess" run.

## 4. Coding Standards

### Python (Backend)
- **Typed Boundaries:** Use Pydantic for all external boundaries:
  - API requests/responses
  - DB read/write models
  - Model inputs/outputs (post-normalization)
  Internal intermediate transforms may use dicts, but must normalize into typed models before persistence or returning responses.
- **DB is System of Record:** Persist milestones early/often (job creation, ingestion, extraction results, save receipts). Ephemeral in-memory state is allowed only within a single job execution boundary and must not be the only copy.
- **Structured Generation:** When extracting, require strict JSON. Use schemas/regex constraints where supported. Never “prompt and pray.”
- **Schema Contracts:** Orchestrator must validate + normalize model output and guarantee contracts:
  - `extracted_json.triples` must always exist and be a list (possibly empty).
- **Error Handling:** Fail fast on invalid inputs. Wrap all network/DB calls with try/except, log clearly, and surface failures in job status or API responses. No silent success.
- **Idempotency:** Any write-heavy operations (save extraction, apply patch) must be idempotent via keys/hashes.
- **Immutable State Management**: Nodes MUST NOT mutate the `PaperState` dict in-place. Every node must return a new dictionary: `return {**state, "new_key": value}`.
- **Unified LLM Gateway**: NO direct `requests.post` to SGLang. All inference MUST pass through `llm_client.chat()` to ensure uniform telemetry (duration_ms, tokens, expert_metadata).
- **Role-Driven Prompts**: System prompts are NOT hardcoded strings. They must be loaded dynamically from the `RoleRegistry` (ArangoDB/defaults.json) at runtime.
- **Precision Management**: Expert precision is role-specific (e.g., Worker=INT4, Brain=FP8, Logician=FP16) to optimize DGX Spark VRAM.

### Testing Strategy (The "Two Lanes")
- **Unit Tests (`src/tests/unit`):** - **Rule:** ZERO IO allowed. No DB, no Network, no File System.
  - **Mechanism:** Must use `mock_*_firewall` fixtures (autouse) from `conftest.py`.
  - **Patches:** Patch libraries at the **Source** (e.g., `arango.ArangoClient`), never the consumer.
- **Integration Tests (`src/tests/integration`):**
  - **Rule:** Real Docker connections allowed.
  - **Mechanism:** Use `real_stack` fixture. Skips if Docker is down.
- **Execution:** - Default: `./scripts/run_tests.sh` (Unit only).
  - CI/Gate: `./scripts/run_tests.sh --integration` (Full stack).

### Test Mocking Protocol (The "Golden Rule")

**The Golden Rule:** Never mock a project file. Always mock the library.

- ❌ **BAD (Brittle):** `@patch('src.orchestrator.nodes.ArangoClient')`
  - Fails if `nodes.py` changes from `from arango import ArangoClient` to `import arango`
- ✅ **GOOD (Robust):** `@patch('arango.ArangoClient')`
  - Works regardless of how the code imports it

**Protocol for Fixing Tests (Analyze First, Act Second):**

1. **Scan Imports:** Before patching, check how the module under test imports the dependency.
   - Use `grep` or `codebase_search` to find the import statement
   - Identify the source library (e.g., `arango`, `requests`, `pathlib`)

2. **Check Fixtures:** Do not manually `@patch` a dependency if a global `mock_*_firewall` fixture already exists.
   - Check `src/tests/unit/conftest.py` for autouse fixtures
   - Use the fixture instead of manual patches

3. **Verify Scope:** Ensure autouse fixtures are actually active in the test's directory scope.
   - Unit tests in `src/tests/unit/` automatically inherit firewall fixtures
   - Integration tests in `src/tests/integration/` use real connections

4. **Use State Fixtures:** Never handwrite state dictionaries.
   - Always use `base_node_state` fixture from `src/tests/conftest.py`
   - Extend it with test-specific fields: `state = {**base_node_state, "custom_field": value}`

**When Internal Function Patches Are Acceptable:**

It's acceptable to patch internal functions (`src.orchestrator.*`) if:
1. They are pure business logic (not I/O wrappers)
2. The test is specifically testing that function's behavior
3. There's no library equivalent to patch

**Examples of Acceptable Internal Patches:**
- `@patch("src.orchestrator.nodes.route_to_expert")` - Business logic function
- `@patch("src.orchestrator.normalize.normalize_extracted_json")` - Internal transformation

**Examples of Unacceptable Internal Patches:**
- `@patch("src.orchestrator.server.get_job_record")` - Should use `arango.ArangoClient` mock via firewall
- `@patch("src.orchestrator.api.knowledge._get_db")` - Should use `arango.ArangoClient` mock via firewall

### TypeScript (Frontend)
- **Workbench UX:** Prioritize density and data visibility over marketing gloss.
- **Mutations:** Prefer Next.js Server Actions (or a thin API layer) for backend mutations with clear typing.
- **State:** Maintain `ActiveProject` state centrally (Context is fine for MVP; keep room for expansion).
- **UI Components:** Use Shadcn/UI. Add a redline/diff view for patch review.

## 5. External Reviewers (Optional Mode)
- **Default Mode:** Local-only inference on DGX.
- **Outside Review Mode (Explicit):** External LLMs (ChatGPT/Gemini/Perplexity) are allowed only for review/breadth checks.
  - Outputs must be imported as `ReviewComment` objects.
  - External outputs must never directly mutate the manuscript or the graph-of-record.
  - The system must convert review notes into internal tasks/patch proposals.

## 6. Critical Invariants (Non-Negotiable)
- **Cortex generates; Orchestrator guarantees.**
  - Cortex produces structured output.
  - Orchestrator validates/normalizes and enforces schema contracts.
- **ArangoDB is the system of record.**
  - If it’s not persisted, it didn’t happen.
- **Project-scoped everything.**
  - Documents, claims, drafts, patches, reviews are always linked to a `project_id`.
- **No silent failures.**
  - Save failures must propagate (job FAILED or API error).
- **Local-first.**
  - External reviewers are opt-in and isolated (Section 5).
  - **State Schema Enforcement**: `PaperState` must be validated at node entry/exit. "Empty success" is a failure; jobs must be marked `FAILED` if schema drift is detected.
- **DGX Resource Guardrails**: 
    - GPU Pinning: Models must be pinned to specific `CUDA_VISIBLE_DEVICES`.
    - KV-Cache Backpressure: Pause or queue jobs if KV cache utilization > 0.95.
- **UTC Sovereignty**: All timestamps MUST be `datetime.now(timezone.utc).isoformat()`. No naive/local timestamps.
- **PDF-Optionality**: The Workbench must support a 2-panel layout if `pdfUrl` is missing, ensuring OOB research is accessible.

## 7. Navigation & UX Contracts
- **Canonical Entry**: `/` must redirect to `/projects`.
- **Metadata Persistence**: Reprocess/Resume flows must preserve `pdfUrl` in query params to maintain visual context.
- **Symbolic Visibility**: Claims with mathematical verification must render the underlying LaTeX and code in the UI for human audit.