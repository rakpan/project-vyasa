# Project Vyasa: The Local Agentic Research Factory

You are an expert AI Research Engineer building "Project Vyasa," a high-performance, thesis-driven research engine running locally on NVIDIA DGX.

## 1. Core Philosophy (The "Native Vision")
- **Factory, Not Chatbot:** We build artifacts (Graphs, Manuscripts), not conversations.
- **Intent-Driven:** All execution is downstream of a `ProjectConfig` (Thesis + RQs + Anti-Scope).
- **System of Record:** The Graph (ArangoDB) is the source of truth. External LLMs are untrusted "Outside Reviewers" (see Section 5).
- **Block-Based:** Manuscripts are lists of bound blocks (Text + ClaimIDs + CitationKeys), not raw strings.

## 2. The Fusion Stack (Architecture)
Use strictly functional names in code and APIs (project, claim, block, patch, guard). Avoid metaphor names for core components.

- **Orchestrator** (`orchestrator` @ :8000): Python + LangGraph. Owns state machines, workflow loops, retries, and tool calls.
- **Cortex** (`cortex-*` @ :30000+): SGLang model servers.
  - **Worker Model:** `Llama-3.3-Nemotron-Super-49B-v1.5` (Extraction, Tagging, strict JSON)
  - **Brain Model:** `Llama-3.3-70B` (Synthesis, critique, reasoning).
  - **Vision Model:** `Qwen2-VL-72B` (Figure/table/chart interpretation).
- **Graph** (`graph` @ :8529): ArangoDB. Stores Projects, Documents, Claims, Manuscripts, Revisions, Reviews.
- **Console** (`console` @ :3000): Next.js. Project management + editorial workbench (section editor + redline review).
- **Vector** (`vector` @ :6333): Retrieval index behind an interface (Qdrant or pgvector). Used for semantic search over chunks/claims.

## 3. The Four Kernels (Domain Logic)
Organize code into these four domains (folders/modules/services). Do not blur responsibilities.

### A. Project Kernel (Intent)
- **Responsibility:** Scope & direction.
- **Key Object:** `ProjectConfig` (Thesis, RQs, Anti-Scope, Seed Corpus, Target Journal profile).
- **Invariant:** No agent runs without a `project_id`. Project context is injected into every prompt/tool call.

### B. Knowledge Kernel (Evidence)
- **Responsibility:** Ingestion & alignment.
- **Key Object:** `Claim` (claim_text, confidence, evidence_spans, source pointers).
- **Logic:**
  - Extract broadly (high recall).
  - **Tag** priority (`HIGH`/`LOW`) based on Project RQs.
  - Do NOT hard-filter at ingestion; tag and rank instead.

### C. Manuscript Kernel (Production)
- **Responsibility:** Assembly, edits, versioning.
- **Key Objects:** `Block` (Paragraph/Figure/Table/Equation) and `Patch` (Edit Operation).
- **Invariant:** Every text block must bind to specific `Claim_IDs` and `Citation_Keys`.
- **Editing Model:** Agents propose patches (block-level replace/insert/delete). Humans accept/reject (redline review).

### D. Governance Kernel (Quality)
- **Responsibility:** Safety & validation gates.
- **Key Objects:** `Guard` (Drift, Citation, Evidence, Contract).
- **Logic:** Roles (prompts) are versioned configuration in the DB, not hardcoded strings in code.

## 4. Coding Standards

### Python (Backend)
- **Typed Boundaries:** Use Pydantic for all external boundaries:
  - API requests/responses
  - DB read/write models
  - Model inputs/outputs (post-normalization)
  Internal intermediate transforms may use dicts, but must normalize into typed models before persistence or returning responses.
- **DB is System of Record:** Persist milestones early/often (job creation, ingestion, extraction results, save receipts). Ephemeral in-memory state is allowed only within a single job execution boundary and must not be the only copy.
- **Structured Generation:** When extracting, require strict JSON. Use schemas/regex constraints where supported. Never “prompt and pray.”
- **Schema Contracts:** Orchestrator must validate + normalize model output and guarantee contracts:
  - `extracted_json.triples` must always exist and be a list (possibly empty).
- **Error Handling:** Fail fast on invalid inputs. Wrap all network/DB calls with try/except, log clearly, and surface failures in job status or API responses. No silent success.
- **Idempotency:** Any write-heavy operations (save extraction, apply patch) must be idempotent via keys/hashes.

### TypeScript (Frontend)
- **Workbench UX:** Prioritize density and data visibility over marketing gloss.
- **Mutations:** Prefer Next.js Server Actions (or a thin API layer) for backend mutations with clear typing.
- **State:** Maintain `ActiveProject` state centrally (Context is fine for MVP; keep room for expansion).
- **UI Components:** Use Shadcn/UI. Add a redline/diff view for patch review.

## 5. External Reviewers (Optional Mode)
- **Default Mode:** Local-only inference on DGX.
- **Outside Review Mode (Explicit):** External LLMs (ChatGPT/Gemini/Perplexity) are allowed only for review/breadth checks.
  - Outputs must be imported as `ReviewComment` objects.
  - External outputs must never directly mutate the manuscript or the graph-of-record.
  - The system must convert review notes into internal tasks/patch proposals.

## 6. Critical Invariants (Non-Negotiable)
- **Cortex generates; Orchestrator guarantees.**
  - Cortex produces structured output.
  - Orchestrator validates/normalizes and enforces schema contracts.
- **ArangoDB is the system of record.**
  - If it’s not persisted, it didn’t happen.
- **Project-scoped everything.**
  - Documents, claims, drafts, patches, reviews are always linked to a `project_id`.
- **No silent failures.**
  - Save failures must propagate (job FAILED or API error).
- **Local-first.**
  - External reviewers are opt-in and isolated (Section 5).